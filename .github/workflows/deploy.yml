# ChittyConnect CI/CD — aligned with chittyos/chittyops conventions
#
# NOTE: chittyconnect cannot use reusable-worker-deploy.yml because that
# workflow calls getchitty-creds → connect.chitty.cc/credentials/deploy
# to fetch ephemeral CF tokens.  ChittyConnect IS the credential provider,
# so it must deploy with static CLOUDFLARE_API_TOKEN (chicken-and-egg).
#
# Structure mirrors the reusable workflow: validate → deploy → verify.

name: Deploy ChittyConnect

on:
  push:
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: read

concurrency:
  group: deploy-chittyconnect-${{ github.ref }}
  cancel-in-progress: true

env:
  NODE_VERSION: "20"

jobs:
  #########################################
  # Validate & Migrate
  #########################################
  validate:
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - run: npm ci

      - name: Validate OpenAPI
        run: |
          SPEC="openapi.json"
          [ ! -f "$SPEC" ] && [ -f "public/openapi.json" ] && SPEC="public/openapi.json"
          [ -f "$SPEC" ] && npx @redocly/cli lint "$SPEC" || echo "No OpenAPI spec"

      - name: Validate MCP Manifest
        run: |
          [ -f "mcp/manifest.json" ] && [ -f "mcp/manifest.schema.json" ] && \
            npx ajv validate -s mcp/manifest.schema.json -d mcp/manifest.json || \
            echo "MCP manifest validation skipped"

      - name: Run D1 Migrations
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          if [ -d migrations ]; then
            for migration in migrations/*.sql; do
              if [ -f "$migration" ]; then
                echo "Applying $migration..."
                npx wrangler d1 execute chittyconnect --file "$migration" --remote || echo "Migration may already be applied"
              fi
            done
          fi

  #########################################
  # Deploy to Cloudflare Workers
  #########################################
  deploy:
    needs: validate
    runs-on: ubuntu-latest
    environment: production
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - run: npm ci

      - name: Deploy to Cloudflare
        uses: cloudflare/wrangler-action@v3
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}

  #########################################
  # Post-deploy verification + rollback
  #########################################
  verify:
    needs: deploy
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          sparse-checkout: wrangler.toml

      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Verify Deployment
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          # Cloudflare WAF blocks GitHub Actions IPs (403), so we verify
          # via the Cloudflare API instead of curling public endpoints.
          echo "Checking deployment status via Cloudflare API..."

          RESPONSE=$(curl -sf \
            "https://api.cloudflare.com/client/v4/accounts/${CLOUDFLARE_ACCOUNT_ID}/workers/scripts/chittyconnect/deployments" \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}") || {
            echo "::error::Failed to query Cloudflare deployments API"
            exit 1
          }

          VERSION=$(echo "$RESPONSE" | python3 -c "
          import json, sys
          data = json.load(sys.stdin)
          deployments = data.get('result', {}).get('deployments', [])
          if deployments:
              latest = deployments[0]
              for v in latest.get('versions', []):
                  print(v.get('version_id', 'unknown'))
          else:
              print('none')
          ")

          echo "Active deployment version: $VERSION"
          [ "$VERSION" != "none" ] && echo "Deployment verified" || {
            echo "::error::No active deployment found — rolling back..."
            npx wrangler@latest rollback -y
            exit 1
          }

      - name: Register with ChittyRegistry
        run: |
          curl -sf -X POST https://registry.chitty.cc/api/services/chittyconnect/heartbeat \
            -H "Content-Type: application/json" \
            -d '{"status":"deployed","version":"${{ github.sha }}"}' || true
        continue-on-error: true
